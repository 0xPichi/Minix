****** LUNES 09/02/2015 *************** 16:00 ********************************************************************************************* 
**************************************************** VI **********************************************************************************

El editor de textos Vi tiene dos modos el modo de edición y el modo comandos los comandos basicos del Vi son:

	- ESC -> Salir al modo comando.
	- i -> Insertar en la posicion en la que se encuentre el cursor.
	- a -> Instertar en la posicion siguiente a la que se encuentra el cursor.
	- x -> Borra la posicion en la que se encuentre el cursor.
	- nyy -> Copiar la linea en la que se encuentra situado el cursor.
	- p -> Pegar en la posicion en la que se encuentre el cursor.
	- ndd -> Borra n lineas empezando en la que se encuentra el cursor
	- u -> Deshacer el ultimo cambio efectuado.
	- :q -> Salir del editor.
	- :q! -> Forzar salida del editor.
	- :w -> Guardar los cambios realizados.
	- :wq -> Guardar y salir del editor.
	- /loquebuscas -> Busca la cadena loquebuscas en el fichero
	- :lineaquebuscas -> Busca la linea lineaquebuscas en el fichero.
	- G -> Baja hasta el final del fichero.
	- Ctrl+g -> Muestra el nombre del fichero entre otras cosas.
	- o -> Coloca el cursor en la line inferior a la acrual.
	- O -> Coloca el cursor en la linea posterior a la actual.
	- A -> Coloca el sursor al final de la linea.
	- % -> Con el cursor colocado en una llave o parentesis desplaza el cursor hasta la llave o parentesis que lo cierran.

Para movernos por el texto se utilizan las flechas de direccion del teclado en el modo comando, en caso de no funcionar los cursores puede ser debido a que el BloqNum esta activado, es importante asegurarse de que esté desactivado antes de comenzar a trabajar.

***************PRACTICA A****************************************************************************************************

El archivo /etc/passwd es un archivo en el cual se guardan varias configuraciones del sistema en Linux.
Uno de los lenguajes mas importantes que seria bueno aprender en la actualidad es el lengujae "shell".
· COMPILACIÓN DEL NÚCLEO 

Añadida la referencia a el comando VI para buscar en un fichero por facilidad de trabajo.
PROBLEMA: A pesar de que añadimos un printf, no se muestra en la pantalla de inicio.
EXPLICACIÓN: Error evidente, aún no se había compilado el nuevo kernel, por lo que el mensaje solo era una linea de texto en un fichero

Compilamos el núcleo y comprobamos que efectivamente se hace un "cp image /dev/hd1a:/minix/2.0.0r12", es decir, se hace una copia del nuevo nucleo con su revisión en /minix (aparece la version 2.0.0r12 cuando "ls /minix"). Ahora si que aparece el mensaje añadido de bienvenida cuando reiniciamos el sistema. También probamos a borrar /minix/2.0.0r12 para comprobar que al reiniciar no aparece el mensaje modificado, ya que se ejecuta la anterior copia del núcleo.

· PROGRAMA EN C 


Para crear un programa en C utilizaremos "$ vi creaH.c". En primer lugar debemos importar los ficheros de cabecera necesarios para las funciones que vamos a utilizar, a continuacion declaramos las variables externas.
#import <stdlib.h>
#import <errno.h>

main (int argc, char *argv[]){

Declararemos una variable de tipo entero que se llamara "numH", lo primero que haremos es comprobar que me han pasado el numero de  los argumentos correctamente:

int numH, i, ret ;
"if(argc != 2){
	printf("creaH <numHijos>\n");
	exit(-1);
	}"

A continuacion comprobaremos los argumentos que hay en "argv[]", como lo que entra por teclado no es un numero sino una cadena de caracteres alfanumericos, lo que habria almacenado en la posicion 0 de "argv[0]"seria una cadena de caracteres, para pasarlo a un entreo utilizaremos la funcion "atoi" para el cual habria que incluir el fichero de cabecera "stdlib.h" (esto lo vemos con "$ man atoi")

numH = atoi(argv[1]);
for(i = 0; i < numH-1; i++){
	if((ret = fork()) == 0){    /* Se almacena en ret el valor del fork y luego compara con el 0. */
	hijo();
	exit(0);
	}
	else if (ret < 0){
		/*error en fork*/
		perror("fork");
		printf("Creados %d, procesos\n", i);
		exit(-1);
	}
}

Despues habrá que declarar la funcion "hijo()". No hará nada, solo emula la estructura del código

hijo(){	
}

Para compliar saldremos de Vi con ":wq", y utilizaremos el comando: "cc -o creaH creaH.c", el ejecutable ha de llamarse siempre igual que el codigo pero sin la extension.

La finalidad de este programa es ver cuantos procesos se pueden crear en un sistema MINIX.
Para ejecutar este programa una vez compilado:
$ ./creaH "numHilos" 

PROBLEMA: No conseguimos compilar el programa y ejecutarlo (solucionado el dia 23/2/2015, mirar en esta fecha)

*************************JUEVES 19/02/2015******************PRACTICA B****************************************************************


Para encontrar la funcion que trata la llamada al sistema de "fork()", seguimpos la pista de las diferentes funciones tal y como aparece en el encunciado de la practica hasta llegar a "call_vec[]", el cual es un vector de funciones que guarda los nombres de las diferentes funciones para tratar las llamadas al sistema.

Seguimiento completo de una llamada fork();
	
	1º- (MU) Cuando invocamos desde un programa la llamda al sistema fork() (posix/_fork.c), se ejecuta una llamada a la funcion _syscall(MM, FORK, &m).

	EXPLICACION:

	Es interesante señalar que que la funcion fork() devuelve un valor del tipo pid_t, que es el PID del hijo que se da al padre al ejecutar la llamada. 
	Observando el codigo de otras llamadas al sistema como wait(), podemos ver que en todas ellas se sigue el patron de llamada a _syscall(MM, *, &m), por lo que * es el argumento mas importante de este paso, ya que es el que identifica el tipo de llamada al sistema que estamos realizando.
	El parametro m se declara de tipo message en la funcion fork(); 

	2º- (MU) Esta funcion invoca a su vez a _sendrec().

	EXPLICACION:

	El parametro m, ya declarado en fork(), se empieza a definir en la funcion _syscall(), llenando el campo m_type(El tipo de datos message corresponde a una estructura que se basa en dos variables: m_source, que indica quien manda el mensaje y m_type, que indica que tipo de mensaje es.).En este caso el tipo de mensaje definido es FORK.
	A la funcion _sendrec() se le pasan como parametros el servidor que ha de tratar la llamada al sistema (MM) y el mensaje con el tipo ya definido.

	3º- (MU) Desde _sendrec() lanza la interrupcion software int SYSVEC la cual hace que a partir de este punto el procesador cambie a modo privilegiado(MP).

	EXPLICACION:

	El compilador de C guarda en la pila los argumentos de llamada a una funcion, por eso la funcion en ensamblador sendrec guarda esos valores en los registros de proposito general y despues realiza la interrupcion (que utilizará los valores de estos registros para definir como se ha de tratar la interrupcion).
	La interrupcion que se lanza es la 0x21. 

**********************************************SABADO 21/02/2015****************************************************************************************

	4º- (MP) El sistema pasara al tratamiento de la interrupcion para ello la funcion prot_init() inicializa la tabla de vectores de interrupción. La recepcion de la interrupcion esta asociada con la funcion s_call().

	EXPLICACION:

	idt es una variable global declarada en protect.c como un vector de struct gatedesc_s de tamaño IDT_SIZE. Siguiendo la pista a IDT_SIZE lo encontramos definido en protect.h con el valor IRQ8_VECTOR + 8, estando esta definida en const.h con el valor 48 (0x30), por lo que el vector tiene tamaño 56. 	
	En la funcion int_gate() es donde se referencia a idt[33] (el argumento formal vec_nr tomar el valor 33) asignandole la correspondencia con s_call.

	Comprobando la linea 206 del archivo /usr/src/kernel/protect.c con el nuevo comando añadido a la lista de Vi, observamos que el vector SYS386_VECTOR esta asociado con la funcion s_call().

	5º- (MP) La funcion s_call() invoca a la funcion sys_call(), cuyos argumentos habian sido insertados previamente en la pila.

	6º- (MP) La funcion sys_call() es la encargada de enviar el mensaje al servidor apropiado en el ejemplo del fork() el servidor es MM y el mensaje es FORK (Este FORK es una constante que represantará la llamada a la funcion que tratará a fork() en call_vec[]).

	EXPLICACION:

	La funcion sys_call() recibe tres parametros, el mas relevante es el primero de ellos "function", que determina si se va a enviar un mensaje, recibir un mensaje o ambos.
	La funcion que se invoca para enviar el mensaje al servidor es mini_send(), la cual se encarga de comprobar que el receptor del mensaje esta esperando ha recibir dicho mensaje, tras enviar el mensaje, bloquea el proceso que envia el mensaje. La funcion que se invoca para recibir el mensaje es mini_rec(), que comprobará que tiene un mensaje para recibir y desbloquea el emisor de este mensaje.


	7º- (MP) Una vez que sys_call() ha enviado el mensaje a MM, se ejecuta _restart() en mpx386.s. Esta funcion permitira continuar con la ejecucion de otro proceso, normalmente en nuestro caso sera MM ya que ha de tratar el mensaje que previamente le habia mandado sys_call(), en este punto el procesador vuelve de nuevo a modo usuario (MU) 

	8º- (MU) El main del MM que estaba a la espera de recibir un mensaje ejecutando en un bucle infinito la funcion get_work(), una vez ha recibido el mensaje se invoca a la funcion que ha de tratarlo a traves de un vector de funciones llamado call_vec[], en nuestro caso call_vec[2] = do_fork, esta sera la funcion encargada del tratamiento de la llamada al sistema.

	EXPLICACION Y RESPUESTA EJERCICIO 2:

	En el main de usr/src/mm/main.c se declaran e inicializan las variables que usará el gestor de memoria llamando a la funcion mm_init() (podemos ver que ésta inicialización se realiza con el arranque del sistema porque están escritos los printf con información de la memoria que se muestran en el login). Después de esta inicialización el gestor entra en un bucle infinito: lo primero que hará será llamar a la función get_work, que intentará leer un mensaje mediante la funcion receive y en caso de conseguirlo lo "decodificará" definiendo los nuevos valores para who y mm_call. Esta última variable será especialmente importante ya que almacena el tipo de mensaje enviado (call number) que en nuestro caso, recordemos, será FORK = 2. Este valor es un "call number" valido por lo que se ejecutará (*call_vec[mm_call])(). En este punto debemos buscar dónde se encuentra inicializado el vector call_vec[], por lo que hacemos "grep call_vec *" en el directorio mm en el que nos encontramos: el resultado es table.c. En este fichero vemos el vector y buscamos la posición 2 correspondiente al mensaje de FORK, que nos conduce a la función do_fork. De nuevo hacemos "grep do_fork *" para buscar donde se encuentra esta función y obtenemos como resultado el fichero forkexit.c. Es aquí donde añadiremos el printf con el saludo.

	Como complemento a la practica A nos fijamos en la linea de la función do_fork que comprueba if (procs_in_use == NR_PROCS) return EAGAIN, lo que justifica empiricamente por qué al cambiar el valor de la constante NR_PROCS pueden coexistir mas procesos, es decir, pueden hacerse mas fork().

	*****************************************MIERCOLES 25/02/2015************************************************************************************

	Tras la realizacion de la modificacion en la practica "B", comprobamos su funcionamiento compilando nuevamente el nucleo desde /usr/src/tools ejecutando el comando "make hdboot" y reiniciando el sistema vemos que en el arranque del sistema aparece el mensaje de saludo en repetidas ocasiones y tambien al ejecutar el programa de la practica A (esto es porque se crean procesos para muchas tareas del SO ya que Minix está basado en el modelo de cracion de procesos fork/wait/exit). 
	PROBLEMA: probamos a ejecutar un par de comandos como "ls", "cd". Observamos que tras ejecutar "ls" aparece nuestro saludo y se nos ocurre ir a buscar el "fork" que producia ese saludo al fichero /usr/src/commands/ls.c. Despues de buscarlo en el codigo no lo encontramos.
	EXPLICACION: Nos equivocamos en el concepto, no es ls el que lanza un proceso nuevo mediante fork, sino que es el sistema operativo el que usa fork para crear un nuevo proceso y despues le asigna mediante una instrucción exec el código del programa ls.c que es el que será ejecutado.
	PROBLEMA: El comando "cd" no crea ningun proceso (no muestra nuestro mensaje de saludo cuando lo lanzamos). Como el "ls" si que lo creaba nos parecia raro pensar que otro comando como "cd" no generase ninguno.
	EXPLICACION: La explicacion de este problema es que no todos los comandos generan procesos, sino que invocan una rutina interna del "bash.c"(Programacion en shell).

	EXPLICACION (Problema de compilación del primer programa): El problema residia en que en las versiones mas primitivas de C, como la que compila el compilador cc, las declaraciones de las variables deben de realizarse en las primeras lineas de la función. 
	Una vez arreglado este error podemos ver que el programa falla al crear 27 hijos, sin embargo hemos visto en el fichero /usr/include/minix/config.h que el valor NR_PROCS está definido con el valor 40, que es el número de procesos concurrentes que pueden coexistir en la maquina, por lo que podemos suponer que ya hay 13 procesos en ejecución (getty), y por eso solo quedan 27 para poder ejecutar. Probamos a modificar este fichero de cabecera y cambiar la constante a 100 y al ejecutar el programa creaH podemos ver que se crean hasta 73 hijos, es decir, mas procesos concurrentes.

	*************************************MIERCOLES 4/03/2015*************PRACTICA C******************************

	Comenzamos a implementar nuestra propia llamada al sistema ASOPS de ejemplo que simplemente jugará a modificar e imprimir en pantalla algunos parametros del mensaje que se pasa como información basica de la llamada. Esta llamada al sistema pasará desde la capa de usuario (nivel 4) al servidor de memoria (nivel 3) y de este pasará a la tarea del sistema (nivel 2 - kernel)

	En primer lugar, añadimos la constante alfanumérica que identificará a nuestra llamada en el sistema operativo (por motivos de limpieza del código) en el fichero de cabecera "callnr.h".
	A continuacion haremos las modificaciones propias en el gestor de memoria: 
		· En usr/src/mm/main.c está el bucle que espera la recepción de un mensaje nuevo a este servidor (visto en la practica B), que cuando lo recibe busca en el vector call_vec[] por indice el número de llamada al sistema que se está pidiendo (constante alfanumerica que añadimos anteriormente), por lo que añadiremos en este array (table.c) la entrada correspondiente a nuestro ASOPS con la correspondiente función que ha de invocar en la posición que le toca (esta será el indice de la constante alfanumerica). "call_vec" tiene tamaño NCALLS por lo que si se nos hubiese olvidado incrementar este valor en callnr.h habriamos cometido un error. 
		· También debemos volver operativa esta función, esto implica escribir el prototipo de la funcion en proto.h y desarrollar el codigo de do_asops en un fichero como por ejemplo utility.c. Este código se dividirá en tres secciones: mostrar los parametros del mensaje que le llegan al servidor de memoria, invocar a la tarea del sistema que realizará otra función y almacenar los cambios que la tarea ha realizado.
		Dos cuestiones importantes de señalar acerca de este código son las siguientes: 1º- Los structs de tipo message no tienen campos que se llama m1_i1, m1_i2, etc, sino que  son constantes que estan definidas en type.h para acceder de una forma simple a los campos de la union de estas estructuras (m_u.m_m1.m1i1), 2º- mm_in y mm_out son estrcturas globales que utilizamos para la recepcion y envio del mensaje desde el mm.

	********************************JUEVES 5/03/2015**********************************************

	Seguiremos con las modificaciones de la tarea del sistema:
		· El fichero usr/src/kernel/system.c proporciona una interfaz para atender las llamadas a la tarea del sistema. En este fichero escribimos el prototipo de la función do_asops que ejecutará el kernel, a la que se pasará como parametro el mensaje con la información (se lo pasará _taskcall())
		DUDA: ¿Por qué en el paso del mensaje a MM no hay que pasar el mensaje como argumento y a la SYSTASK si? RESPUESTA: Elección de diseño
		EXPLICACION: 
		· En la rutina sys_task() se demultiplexa a la llamada a la función dependiendo de la llamada al sistema que se produzca (en este caso ASOPS), por lo que tenemos que añadir un case en el switch para invocar a la función do_asops()
		· Escribimos el código de do_asops() en el que haremos algo parecido al del servidor de memoria, es decir, cambiar los parámetros del mensaje e imprimir los anteriores para comprobar que se están efectuando de buena forma los pasos.

    ********************************MIERCOLES 11/03/2015***************PRACTICA D*******************************

    Para terminar la Practica C crearemos una llamada al sistema con una utilidad especial: mostrar información sobre los procesos actualmente en ejecución. Para no tener que hacer todas las modificaciones en todos los ficheros de nuevo, utilizaremos un distribuidor en la función do_asops de el kernel (system.c) que se bifurcará en función del valor m1_i1 (primer campo del primer campo de la unión de message) del mensaje. Estos valores representarán, mediante constantes alfanuméricas que definiremos en usr/include/minix/type.c, a las llamadas al sistema que crearemos a continuación.
    Nuestra llamada para mostrar información de los procesos será MIPS, ejecutada en la funcion do_mips. Esta función recorre todos los procesos existen en el instante de ejecución e imprimir por pantalla información sobre ellos como su PID (se imprime como un entero, ya que en usr/src/kernel/types.c está definido como un tipo "renombrado" de int), nombre, numero de proceso...

    Comenzamos la practica D:

    RETO 1: ¿Milisegundos del ciclo de reloj?
    RETO 2: ¿Por qué el ultimo proceso que se crea es el primero en entrar en CPU?
    
    A continuacion exponemos los factores que nos resultan significativos de las funciones pick_proc(), ready(), unready() y sched() que estan en /usr/src/kernel/proc.c

    	· pick_proc() -> Es la funcion encargada de coger un proceso de la cola de listos y asignarle CPU.
    	 Lo primero que nos llama la atencion es que las colas tienen una prioridad asignada TASK_Q > SERVER_Q > USER_Q por lo cual la funcion trata de asignar CPU en prmer lugar a los procesos listos de la tarea del sistema, en caso de no haber ninguno ejecuta el resto en orden de priodades.
    	 Es en esta funcion donde se define las variables globales proc_ptr y bill_ptr que estan declaradas en proc.h y que representan el proceso que esta actualmente en ejecucion y el proceso que inicia una serie de llamadas al sistema respectivamente.
    	 Podemos ver que la variable bill_ptr solo se utiliza en los procesos de usuario ya que es el unico que puede hacer llamadas al sistema y que necesita saber quien es el emisor de la llamada al que "cobrar" la CPU.
    	 No devuelve el proceso, sino que almacena su neferencia en proc_ptr.

   	*******************************SABADO 14/3/2015***********************************************************************

    	· ready() -> Mete un proceso en la cola de listos. PROBLEMA: ¿Que quiere decir la macro istaskp? EXPLIACION: Realiza la comprobacion de si el proceso es una tarea del sistema. Vemos que la cola de procesos listos se implementa con una politica LIFO (esto se realiza en O(1) y no provoca un problema ya que el PCB se implementa mediante listas enlazadas). Se puede cambiar a una politica FIFO descomentando las lineas siguientes y comentando las anteriores.
    	· unready() -> Saca un proceso de la cola de listos. Es algo menos eficiente que ready(), ya que el proceso que eliminamos no tiene por qué ser el primero y al estar implementado mediante listas enlazadas necesitamos recorrer toda la lista hasta encontrar el proceso (eliminarlo es sencillo, ya que simplemente cambiamos la referencia del nextready del proceso anterior al que queremos eliminar por la del proceso que sigue al eliminado)
    	· sched() -> Se invoca a este metodo cuando el proceso en ejecución ha superado el quantum (demasiado tiempo en CPU). Mete este proceso al final de la cola y pone el que estaba el segundo en la cabeza. A continuación llama a la funcion pick_proc() que, si no hay procesos de tareas o servidores, seleccionará a este proceso para asignarle CPU. Importante señalar que ésta función solo trabaja con procesos de usuario DUDA:¿Es porque las tareas del sistema y procesos de servidores no pueden ser desalojados? EXPLICACION: Efectivamente las tareas del sistema y los procesos de servidores no son desalojados nunca de CPU debido a la politica del sistema operativo.


    	Tras leer y analizar la tarea del reloj llegamos a comprender su funcionamiento:

    	En la inicializacion del sistema se invoca a todas las tareas incluida la tarea del reloj, lo primero que podemos observar que la tarea llama a la funcion init_clock() la cual efectual la inicializacion del temporizador externo, determina el numero de ciclos entre interrupciones, inicializa la rutina de servicio de interrupcion del reloj y habilita las interrupciones. El valor del numero de ciclos entre interrupcion esta definido en const.h como TIMER_FREQ/HZ por lo tanto el reloj interrumpe 60 veces por segundo. Despues de esto la tarea del reloj se queda esperando recibir algun mensaje.
		Por lo tanto el reloj interrumpe 60 veces por segundo lanzando una interrupcion, que es tratada por la CPU llamando a la rutina de servicio de interrupciones del reloj(clock_handler()), lo primero que hace esta rutina de servicio es contar los ticks que lleva que lleva el proceso en ejecucion, esta rutina deberia de actualizar la variable realtime, pero ya que esta esta protegida actualiza pending_ticks y now, la variable sched_ticks cuenta los ticks que le quedan al proceso para finalizar su quantum, se comprueba que llegue a 0 si se da esta situacion se invoca a interrupt(CLOCK), pero solo en caso de que el proceso sea un proceso de usuario.Esto provoca el envio de un mensaje a la tarea del reloj, de tipo HARD_INT, tras la llegada de este mensaje a la tarea del reloj utiliza el distribuidor para ejecutar la funcion asociada a este tipo de mensaje que en el caso de HARD_INT es do_clocktick().
		
 
    ***********************************LUNES 16/3/2015******************************************************************

    EXPLICACION EJERCICIO:

    El algoritmo de planificación Round Robin consiste en fijar el tiempo (quantum) que se permitirá a un proceso utilizar la CPU de forma continuada (cuando se le termina el quantum se le desaloja y pasa a la cola de listos y mas tarde volverá a entrar a continuar con su tarea). A diferencia de este, un algoritmo FIFO provoca que el proceso al que le toca ejecutarse en CPU solo pueda salir cuando ha terminado y no pueda ser desalojado. La ventaja fundamental de RR frente a FIFO es que no retrasa a toda la cola de listos frente a un proceso muy grande, a pesar de que el tiempo de ejecución total del sistema sea el mismo. A esta situación se le llama efecto convoy y es lo que tratamos de visualizar en este ejercicio. Como Minix tiene un algoritmo de planificación RR con un quantum de 6 ticks y queremos convertirlo a FIFO, procederemos a aumentar este quantum a un numero alto, lo que provocará que el proceso tarde mucho en ser desalojado (simulando que nunca será desalojado) y que la única forma de liberar la CPU sea por propia voluntad, terminando su ejecución.
    Para realizar la tarea de cambiar el quantum tenemos que crear una nueva llamada al sistema, ya que no podemos modificar una variable de la capa del kernel desde la de usuario. En vez de crear una llamada al sistema desde cero, utilizaremos el distribuidor creado en la llamada ASOPS (creada en la practica anterior), desde el que redirigiremos a la función cambiaQ que crearemos en clock.c cuando llega la llamada CAMBIAQ. 
    IMPORTANTE: Nos prevenimos de no usar ni la constante cuantificadora PRIVATE ni FORWARD en la definición de la función ni en la declaración del prototipo de cambiaQ  en clock.c, ya que a esta función se la llamada desde este fichero system.c y estos cuantificadores impiden el acceso a funciones desde fuera del archivo en el que estan escritas, ya que son una mascara de static (en C significa que esa variable/funcion no es accesible desde fuera del fichero).

	*************************************MARTES 24/3/2015***************************PRACTICA E*****************************************

	DUDA: ¿Cómo imprimir las tablas de segmentos de las tareas del sistema si no estan en el PCB del gestor de memoria?
	EXPLICACION: Dado que las tareas de sistema no se almacenan en el PCB del gestor de memoria devemos hacer la llamada al sistema en el kernel para utilizar su PCB en el cual siq ue se almacenan las tareas del sistema.

	Recorremos el vector p_proc[] en el cual se almacenan tanto los procesos de usuario, procesos de servidores y tareas dle sistema, dado que sabemos que las tareas de sistema se almacenan en primer lugar utilizaremos la constante NR_TASKS para controlar el bucle iterativo que recorrera el PCB, accedemos al campo p_map[] de cada  proceso para imprimir la tabla de segmentos del mismo.

	Creamos la funcion "memLibre()" dado que la tabla de huecos esta definida como static en el fichero alloc.c, sera en este fichero donde crearemos la función. 

	La tarea de la funcion es recorrer la lista enlazada de hole_head imprimiendo la base y el tamaño del hueco.

			while( hp != NIL_HOLE) {

				/*Impresion de los datos*/
				hp = hp->h_next;
			}


	Realizamos algunas pruebas para comprobar el funcionamiento de la tabala de huecos:

		1.-Colocando la llamada en mm_init(), antes de la llamada a mem_init(), el resultado fue la tabla vacia, dado que no se habia ejecutado mem_init()(Es donde se llena la tabla de huecos).

		2.-Colocando la llamada despues de la llamada a mem_init(), el resultado en este caso es una tabla con dos entradas.

		3.-Colocando la llamada en la funcion mem_init(), en el final del bucle el cual pide al kernel la informacion de que espacios de memoria estan sin utilizar para asi poder liberarlos, el resultado fue la evolucion de la tabla(Cada iteraccion del bucle era una nueva entrada en la tabla de huecos).

		Para la impresion de las tablas de segmentos de los procesos de usuario creamos una nueva funcion llamada tabSeg(), la cual se encuentra en /usr/src/mm/utility.c, dado que ya no nos encontramos en el nucleo la estructura de datos que debemos utilizar es el PCB del gestor de memoria (mproc[NR_PROCS]), la cual esta definida en /usr/src/mm/mproc.h.
		La tarea de esta funcion es recorrer las entradas del PCB del gestor de memoria e imprimir la informacion correspondiente a la tabla de segmentos de cada una de las entradas.

		*********************************MIERCOLES 8/04/2015***********************************************************************

		Cansados de tener que acceder continuamente a /usr/src/tools para realizar la compilacion del nucleo en las diferentes pruebas que hemos hecho decidios crear un script el cual nos ahorrara las molestias

		compilak:

			#!bin/sh
			cd /usr/src/tools
			make hdboot

		Una vez escrito basta con moverlo a la carpeta /bin para poder ejecutarlo libremente, indagando un poco acerca de los scripts descubrimos que hay varias formas para ejecutarlos:

			Especificando el interprete: sh compilak
			Refiriendose al directorio en el que estamos con el interptrete predeterminado de nuestro usuario: ./compilak
			De manera global: compoilak