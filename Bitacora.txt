Autores: Sergio Delgado Álvarez y Alberto Amigo Alonso
Grupo: 27

****** LUNES 09/02/2015 *************** 16:00 ********************************************************************************************* 
**************************************************** VI **********************************************************************************

El editor de textos Vi tiene dos modos el modo de edición y el modo comandos los comandos básicos del Vi son:

	- ESC -> Salir al modo comando.
	- i -> Insertar en la posición en la que se encuentre el cursor.
	- a -> Insertar en la posición siguiente a la que se encuentra el cursor.
	- x -> Borra la posición en la que se encuentre el cursor.
	- nyy -> Copiar la línea en la que se encuentra situado el cursor.
	- p -> Pegar en la posición en la que se encuentre el cursor.
	- ndd -> Borra n líneas empezando en la que se encuentra el cursor
	- u -> Deshacer el ultimo cambio efectuado.
	- :q -> Salir del editor.
	- :q! -> Forzar salida del editor.
	- :w -> Guardar los cambios realizados.
	- :wq -> Guardar y salir del editor.
	- /loquebuscas -> Busca la cadena loquebuscas en el fichero
	- :lineaquebuscas -> Busca la línea lineaquebuscas en el fichero.
	- G -> Baja hasta el final del fichero.
	- Ctrl+g -> Muestra el nombre del fichero entre otras cosas.
	- o -> Coloca el cursor en la line inferior a la actual.
	- O -> Coloca el cursor en la línea posterior a la actual.
	- A -> Coloca el cursor al final de la línea.
	- % -> Con el cursor colocado en una llave o paréntesis desplaza el cursor hasta la llave o paréntesis que lo cierran.

Para movernos por el texto se utilizan las flechas de dirección del teclado en el modo comando, en caso de no funcionar los cursores puede ser debido a que el BloqNum esta activado, es importante asegurarse de que esté desactivado antes de comenzar a trabajar.

***************PRACTICA A****************************************************************************************************

El archivo /etc/passwd es un archivo en el cual se guardan varias configuraciones del sistema en los SO tipo Unix.
Recomendable aprender a programar Shell Scripting.

· COMPILACIÓN DEL NÚCLEO 

Añadida la referencia a el comando VI para buscar en un fichero por facilidad de trabajo.
PROBLEMA: A pesar de que añadimos un printf, no se muestra en la pantalla de inicio.
EXPLICACIÓN: Error evidente, aún no se había compilado el nuevo kernel, por lo que el mensaje solo era una línea de texto en un fichero

Compilamos el núcleo y comprobamos que efectivamente se hace un "cp image /dev/hd1a:/minix/2.0.0r12", es decir, se hace una copia del nuevo núcleo con su revisión en /minix (aparece la versión 2.0.0r12 cuando "ls /minix"). Ahora si que aparece el mensaje añadido de bienvenida cuando reiniciamos el sistema. También probamos a borrar /minix/2.0.0r12 para comprobar que al reiniciar no aparece el mensaje modificado, ya que se ejecuta la anterior copia del núcleo

· PROGRAMA EN C 

Para crear un programa en C utilizaremos "$ vi creaH.c". En primer lugar debemos importar los ficheros de cabecera necesarios para las funciones que vamos a utilizar, a continuación declaramos las variables externas.
#import <stdlib.h>
#import <errno.h>

main (int argc, char *argv[]){

Declararemos una variable de tipo entero que se llamara "numH", lo primero que haremos es comprobar que me han pasado el numero de  los argumentos correctamente:

int numH, i, ret ;
"if(argc != 2){
	printf("creaH <numHijos>\n");
	exit(-1);
	}"

A continuación comprobaremos los argumentos que hay en "argv[]", como lo que entra por teclado no es un numero sino una cadena de caracteres alfanuméricos, lo que habría almacenado en la posición 0 de "argv[0]"seria una cadena de caracteres, para pasarlo a un entero utilizaremos la función "atoi" para el cual habría que incluir el fichero de cabecera "stdlib.h" (esto lo vemos con "$ man atoi")

numH = atoi(argv[1]);
for(i = 0; i < numH-1; i++){
	if((ret = fork()) == 0){    /* Se almacena en ret el valor del fork y luego compara con el 0. */
	hijo();
	exit(0);
	}
	else if (ret < 0){
		/*error en fork*/
		perror("fork");
		printf("Creados %d, procesos\n", i);
		exit(-1);
	}
}

Después habrá que declarar la función "hijo()". No hará nada, solo emula la estructura del código

hijo(){	
}

Para compilar saldremos de Vi con ":wq", y utilizaremos el comando: "cc -o creaH creaH.c", el ejecutable ha de llamarse siempre igual que el código pero sin la extensión.

La finalidad de este programa es ver cuantos procesos se pueden crear en un sistema MINIX.
Para ejecutar este programa una vez compilado:
$ ./creaH "numHilos" 

PROBLEMA: No conseguimos compilar el programa y ejecutarlo (solucionado el día 23/2/2015, mirar en esta fecha)

*************************JUEVES 19/02/2015******************PRACTICA B****************************************************************


Para encontrar la función que trata la llamada al sistema de "fork()", seguimos la pista de las diferentes funciones tal y como aparece en el enunciado de la practica hasta llegar a "call_vec[]", el cual es un vector de funciones que guarda los nombres de las diferentes funciones para tratar las llamadas al sistema.

Seguimiento completo de una llamada fork();
	
	1º- (MU) Cuando invocamos desde un programa la llamada al sistema fork() (posix/_fork.c), se ejecuta una llamada a la función _syscall(MM, FORK, &m).

	EXPLICACION:

	Es interesante señalar que la función fork() devuelve un valor del tipo pid_t, que es el PID del hijo que se da al padre al ejecutar la llamada. 
	Observando el código de otras llamadas al sistema como wait(), podemos ver que en todas ellas se sigue el patrón de llamada a _syscall(MM, *, &m), por lo que * es el argumento mas importante de este paso, ya que es el que identifica el tipo de llamada al sistema que estamos realizando (mediante las constantes alfanuméricas de callnr).
	El parámetro m se declara de tipo message en la función fork(); 

	2º- (MU) Esta función invoca a su vez a _sendrec().

	EXPLICACION:

	El parámetro m, ya declarado en fork(), se empieza a definir en la función _syscall(), llenando el campo m_type(El tipo de datos message corresponde a una estructura que se basa en dos variables: m_source, que indica quien manda el mensaje y m_type, que indica que tipo de mensaje es.).En este caso el tipo de mensaje definido es FORK.
	A la función _sendrec() se le pasan como parámetros el servidor que ha de tratar la llamada al sistema (MM) y el mensaje con el tipo ya definido.

	3º- (MU) Desde _sendrec() lanza la interrupción software int SYSVEC la cual hace que a partir de este punto el procesador cambie a modo privilegiado(MP).

	EXPLICACION:

	El compilador de C guarda en la pila los argumentos de llamada a una función, por eso la función en ensamblador sendrec guarda esos valores en los registros de propósito general sacándolos de la pila y después realiza la interrupción (que utilizará los valores de estos registros para definir como se ha de tratar la interrupción).
	La interrupción que se lanza es la 21h. 

**********************************************SABADO 21/02/2015****************************************************************************************

	4º- (MP) El sistema pasara al tratamiento de la interrupción para ello la función prot_init() inicializa la tabla de vectores de interrupción. La recepción de la interrupción esta asociada con la función s_call().

	EXPLICACION:

	idt es una variable global declarada en protect.c como un vector de struct gatedesc_s de tamaño IDT_SIZE. Siguiendo la pista a IDT_SIZE lo encontramos definido en protect.h con el valor IRQ8_VECTOR + 8, estando esta definida en const.h con el valor 48 (0x30), por lo que el vector tiene tamaño 56. 	
	En la función int_gate() es donde se referencia a idt[33] (el argumento formal vec_nr tomar el valor 33) asignándole la correspondencia con s_call.

	Comprobando la línea 206 del archivo /usr/src/kernel/protect.c con el nuevo comando añadido a la lista de Vi, observamos que el vector SYS386_VECTOR esta asociado con la función s_call().

	5º- (MP) La función s_call() invoca a la función sys_call(), cuyos argumentos habían sido insertados previamente en la pila.

	6º- (MP) La función sys_call() es la encargada de enviar el mensaje al servidor apropiado en el ejemplo del fork() el servidor es MM y el mensaje es FORK (Este FORK es una constante que representará la llamada a la función que tratará a fork() en call_vec[]).

	EXPLICACION:

	La función sys_call() recibe tres parámetros, el mas relevante es el primero de ellos "function", que determina si se va a enviar un mensaje, recibir un mensaje o ambos (send, recive o sendrec). En nuestro caso llega sendrec.
	La función que se invoca para enviar el mensaje al servidor es mini_send(), la cual se encarga de comprobar que el receptor del mensaje esta esperando ha recibir dicho mensaje, tras enviar el mensaje, bloquea el proceso que envía el mensaje. La función que se invoca para recibir el mensaje es mini_rec(), que comprobará que tiene un mensaje para recibir y desbloquea el emisor de este mensaje.


	7º- (MP) Una vez que sys_call() ha enviado el mensaje a MM, se ejecuta _restart() en mpx386.s. Esta función permitirá continuar con la ejecución de otro proceso, normalmente en nuestro caso será MM ya que ha de tratar el mensaje que previamente le había mandado sys_call(), en este punto el procesador vuelve de nuevo a modo usuario (MU) 

	8º- (MU) El main del MM que estaba a la espera de recibir un mensaje ejecutando en un bucle infinito la función get_work(), una vez ha recibido el mensaje se invoca a la función que ha de tratarlo a través de un vector de funciones llamado call_vec[], en nuestro caso call_vec[2] = do_fork, esta será la función encargada del tratamiento de la llamada al sistema.

	EXPLICACION Y RESPUESTA EJERCICIO 2:

	En el main de usr/src/mm/main.c se declaran e inicializan las variables que usará el gestor de memoria llamando a la función mm_init() (podemos ver que ésta inicialización se realiza con el arranque del sistema porque están escritos los printf con información de la memoria que se muestran en el login). Después de esta inicialización el gestor entra en un bucle infinito: lo primero que hará será llamar a la función get_work, que intentará leer un mensaje mediante la función receive y en caso de conseguirlo lo "decodificará" definiendo los nuevos valores para who y mm_call. Esta última variable será especialmente importante ya que almacena el tipo de mensaje enviado (call number) que en nuestro caso, recordemos, será FORK = 2. Este valor es un "call number" valido por lo que se ejecutará (*call_vec[mm_call])(). En este punto debemos buscar dónde se encuentra inicializado el vector call_vec[], por lo que hacemos "grep call_vec *" en el directorio mm en el que nos encontramos: el resultado es table.c. En este fichero vemos el vector y buscamos la posición 2 correspondiente al mensaje de FORK, que nos conduce a la función do_fork. De nuevo hacemos "grep do_fork *" para buscar donde se encuentra esta función y obtenemos como resultado el fichero forkexit.c. Es aquí donde añadiremos el printf con el saludo.

	Como complemento a la practica A nos fijamos en la línea de la función do_fork que comprueba if (procs_in_use == NR_PROCS) return EAGAIN, lo que justifica empíricamente por qué al cambiar el valor de la constante NR_PROCS pueden coexistir mas procesos, es decir, pueden hacerse mas fork().

	*****************************************MIERCOLES 25/02/2015************************************************************************************

	Tras la realización de la modificación en la practica "B", comprobamos su funcionamiento compilando nuevamente el núcleo desde /usr/src/tools ejecutando el comando "make hdboot" y reiniciando el sistema vemos que en el arranque del sistema aparece el mensaje de saludo en repetidas ocasiones y también al ejecutar el programa de la practica A (esto es porque se crean procesos para muchas tareas del SO ya que Minix está basado en el modelo de creación de procesos fork/wait/exit). 
	PROBLEMA: probamos a ejecutar un par de comandos como "ls", "cd". Observamos que tras ejecutar "ls" aparece nuestro saludo y se nos ocurre ir a buscar el "fork" que producía ese saludo al fichero /usr/src/commands/ls.c. Después de buscarlo en el código no lo encontramos.
	EXPLICACION: Nos equivocamos en el concepto, no es ls el que lanza un proceso nuevo mediante fork, sino que es el Shell del sistema operativo el que usa fork para crear un nuevo proceso y después le asigna mediante una instrucción exec el código del programa ls.c que es el que será ejecutado.
	PROBLEMA: El comando "cd" no crea ningún proceso (no muestra nuestro mensaje de saludo cuando lo lanzamos). Como el "ls" si que lo creaba nos parecía raro pensar que otro comando como "cd" no generase ninguno.
	EXPLICACION: La explicación de este problema es que no todos los comandos generan procesos, sino que invocan una rutina interna del "bash.c"(Programación en Shell).

	EXPLICACION (Problema de compilación del primer programa): El problema residía en que en las versiones mas primitivas de C, como la que compila el compilador cc, las declaraciones de las variables deben de realizarse en las primeras líneas de la función. 
	Una vez arreglado este error podemos ver que el programa falla al crear 27 hijos, sin embargo hemos visto en el fichero /usr/include/minix/config.h que el valor NR_PROCS está definido con el valor 40, que es el número de procesos concurrentes que pueden coexistir en la maquina, por lo que podemos suponer que ya hay 13 procesos en ejecución (getty, etc), y por eso solo quedan 27 para poder ejecutar. Probamos a modificar este fichero de cabecera y cambiar la constante a 100 y al ejecutar el programa creaH podemos ver que se crean hasta 73 hijos, es decir, mas procesos concurrentes.
	ACLARACIÓN: Los procesos de las tareas del sistema no entran dentro de estos 40 procesos. Son solo procesos de usuario. (Las tareas las define NR_TASKS, no NR_PROCS)

	*************************************MIERCOLES 4/03/2015*************PRACTICA C******************************

	Comenzamos a implementar nuestra propia llamada al sistema ASOPS de ejemplo que simplemente jugará a modificar e imprimir en pantalla algunos parámetros del mensaje que se pasa como información básica de la llamada. Esta llamada al sistema pasará desde la capa de usuario (nivel 4) al servidor de memoria (nivel 3) y de este pasará a la tarea del sistema (nivel 2 - kernel)

	En primer lugar, añadimos la constante alfanumérica que identificará a nuestra llamada en el sistema operativo (por motivos de limpieza del código) en el fichero de cabecera "callnr.h".
	A continuación haremos las modificaciones propias en el gestor de memoria: 
		· En usr/src/mm/main.c está el bucle que espera la recepción de un mensaje nuevo a este servidor (visto en la practica B), que cuando lo recibe busca en el vector call_vec[] por índice el número de llamada al sistema que se está pidiendo (constante alfanumérica que añadimos anteriormente), por lo que añadiremos en este array (table.c) la entrada correspondiente a nuestro ASOPS con la correspondiente función que ha de invocar en la posición que le toca (esta será el índice de la constante alfanumérica). "call_vec" tiene tamaño NCALLS por lo que si se nos hubiese olvidado incrementar este valor en callnr.h habríamos cometido un error. 
		· También debemos volver operativa esta función, esto implica escribir el prototipo de la función en proto.h y desarrollar el código de do_asops en un fichero como por ejemplo utility.c. Este código se dividirá en tres secciones: mostrar los parámetros del mensaje que le llegan al servidor de memoria, invocar a la tarea del sistema que realizará otra función y almacenar los cambios que la tarea ha realizado.
		Dos cuestiones importantes de señalar acerca de este código son las siguientes: 1º- Los structs de tipo message no tienen campos que se llama m1_i1, m1_i2, etc, sino que  son constantes que están definidas en type.h para acceder de una forma simple a los campos de la union de estas estructuras (m_u.m_m1.m1i1), 2º- mm_in y mm_out son estructuras globales que utilizamos para la recepción y envió del mensaje desde el mm.

		ACLARACIÓN: Para añadir los prototipos de las funciones (sus declaraciones) utilizamos la macro _PROTOTYPE a la que pasamos como "parámetros" el nombre de la función y los argumentos. Esta macro transforma esta declaración de dos formas diferentes en función del valor que tenga otra macro. Investigando descubrimos que existen dos tipos de formas de escribir código en C: la originalmente diseñada por sus creadores Kernighan y Ritchie (K&R C) y la estandarizada por la IEEE (ANSI C). Como los diseñadores de Minix no podían saber cuál de estas dos formas iba a ser usada decidieron crear la macro _PROTOTYPE para poder cambiar entre las dos versiones de una forma simple.

	********************************JUEVES 5/03/2015**********************************************

	Seguiremos con las modificaciones de la tarea del sistema:
		· El fichero usr/src/kernel/system.c proporciona una interfaz para atender las llamadas a la tarea del sistema. En este fichero escribimos el prototipo de la función do_asops que ejecutará el kernel, a la que se pasará como parámetro el mensaje con la información (se lo pasará _taskcall())
		DUDA: ¿Por qué en el paso del mensaje a MM no hay que pasar el mensaje como argumento y a la SYSTASK si? 
		RESPUESTA: Elección de diseño de los desarrolladores de Minix.
		EXPLICACION: 
		· En la rutina sys_task() se demultiplexa a la llamada a la función dependiendo de la llamada al sistema que se produzca (en este caso ASOPS), por lo que tenemos que añadir un case en el switch para invocar a la función do_asops()
		· Escribimos el código de do_asops() en el que haremos algo parecido al del servidor de memoria, es decir, cambiar los parámetros del mensaje e imprimir los anteriores para comprobar que se están efectuando de buena forma los pasos.

    ********************************MIERCOLES 11/03/2015***************PRACTICA D*******************************

    Para terminar la Practica C crearemos una llamada al sistema con una utilidad especial: mostrar información sobre los procesos actualmente en ejecución. Para no tener que hacer todas las modificaciones en todos los ficheros de nuevo, utilizaremos un distribuidor en la función do_asops de el kernel (system.c) que se bifurcará en función del valor m1_i1 (primer campo del primer campo de la unión de message) del mensaje. Estos valores representarán, mediante constantes alfanuméricas que definiremos en usr/include/minix/type.c, a las llamadas al sistema que crearemos a continuación.
    Nuestra llamada para mostrar información de los procesos será MIPS, ejecutada en la función do_mips. Esta función recorre todos los procesos existen en el instante de ejecución (utilizando pproc_addr, que guarda por orden de llegada las direcciones de los procesos, y la mascara P_SLOT_FREE negando el resultado) e imprime por pantalla información sobre ellos como su PID (se imprime como un entero, ya que en usr/src/kernel/types.c está definido como un tipo "renombrado" de int), nombre, numero de proceso, tiempo de usuario y tiempo de CPU...

    Comenzamos la practica D:

    RETO 1: ¿Milisegundos del ciclo de reloj? La definición del quantum de minix se encuentra en /usr/src/kernel/clock.c definida como SCHED_RATE (MILLISEC*HZ/1000), dado que MILLISEC definido también en este archivo tiene un valor de 100 y HZ un valor de 60 definido en /usr/include/minix/cons.h, por lo tanto el valor definido para SCHED_RATE es de 6 ticks siendo cada tick 1000/60 milisegundos el valor del quanto de minix es 100 milisegundos.
    RETO 2: ¿Por qué el ultimo proceso que se crea es el primero en entrar en CPU? Explicado con la función ready()
    
    A continuación exponemos los factores que nos resultan significativos de las funciones pick_proc(), ready(), unready() y sched() que están en /usr/src/kernel/proc.c

    	· pick_proc() -> Es la función encargada de coger un proceso de la cola de listos y asignarle CPU.
    	 Lo primero que nos llama la atención es que las colas tienen una prioridad asignada TASK_Q > SERVER_Q > USER_Q por lo cual la función trata de asignar CPU en primer lugar a los procesos listos de la tarea del sistema, en caso de no haber ninguno ejecuta el resto en orden de prioridades.
    	 Es en esta función donde se define las variables globales proc_ptr y bill_ptr que están declaradas en proc.h y que representan el proceso que esta actualmente en ejecución y el proceso que inicia una serie de llamadas al sistema respectivamente.
    	 Podemos ver que la variable bill_ptr solo se utiliza en los procesos de usuario ya que es el único que puede hacer llamadas al sistema y que necesita saber quien es el emisor de la llamada al que "cobrar" la CPU.
    	 No devuelve el proceso, sino que almacena su referencia en proc_ptr.

   	*******************************SABADO 14/3/2015***********************************************************************

    	· ready() -> Mete un proceso en la cola de listos. PROBLEMA: ¿Que quiere decir la macro istaskp? EXPLIACION: Realiza la comprobación de si el proceso es una tarea del sistema. Vemos que la cola de procesos listos se implementa con una política LIFO (esto se realiza en O(1) y no provoca un problema ya que el PCB se implementa mediante listas enlazadas). Se puede cambiar a una política FIFO descomentando las líneas siguientes y comentando las anteriores. Es sencillo leyendo el código darse cuenta de esto, ya que en la implementación LIFO se mete toda la cola detrás del proceso que vamos a añadir y después se pone este el primero y en la FIFO se le coloca el último.
    	· unready() -> Saca un proceso de la cola de listos. Es algo menos eficiente que ready(), ya que el proceso que eliminamos no tiene por qué ser el primero y al estar implementado mediante listas enlazadas necesitamos recorrer toda la lista hasta encontrar el proceso (eliminarlo es sencillo, ya que simplemente cambiamos la referencia del nextready del proceso anterior al que queremos eliminar por la del proceso que sigue al eliminado)
    	· sched() -> Se invoca a este método cuando el proceso en ejecución ha superado el quantum (demasiado tiempo en CPU). Mete este proceso al final de la cola y pone el que estaba el segundo en la cabeza. A continuación llama a la función pick_proc() que, si no hay procesos de tareas o servidores, seleccionará a este proceso para asignarle CPU. Importante señalar que ésta función solo trabaja con procesos de usuario DUDA:¿Es porque las tareas del sistema y procesos de servidores no pueden ser desalojados? EXPLICACION: Efectivamente las tareas del sistema y los procesos de servidores no son desalojados nunca de CPU debido a la política del sistema operativo.


    Tras leer y analizar la tarea del reloj llegamos a comprender su funcionamiento:

   	En la inicialización del sistema se invoca a todas las tareas incluida la tarea del reloj, lo primero que podemos observar que la tarea llama a la función init_clock() la cual efectúa la inicialización del temporizador externo, determina el numero de ciclos entre interrupciones, inicializa la rutina de servicio de interrupción del reloj y habilita las interrupciones. El valor del numero de ciclos entre interrupción esta definido en const.h como TIMER_FREQ/HZ por lo tanto el reloj interrumpe 60 veces por segundo. Después de esto la tarea del reloj se queda esperando recibir algún mensaje.
	Por lo tanto el reloj interrumpe 60 veces por segundo lanzando una interrupción, que es tratada por la CPU llamando a la rutina de servicio de interrupciones del reloj(clock_handler()), lo primero que hace esta rutina de servicio es contar los ticks que lleva que lleva el proceso en ejecución, esta rutina debería de actualizar la variable realtime, pero ya que esta protegida actualiza pending_ticks y now, la variable sched_ticks cuenta los ticks que le quedan al proceso para finalizar su quantum, se comprueba que llegue a 0 si se da esta situación se invoca a interrupt(CLOCK), pero solo en caso de que el proceso sea un proceso de usuario. Esto provoca el envió de un mensaje a la tarea del reloj, de tipo HARD_INT, tras la llegada de este mensaje a la tarea del reloj utiliza el distribuidor para ejecutar la función asociada a este tipo de mensaje que en el caso de HARD_INT es do_clocktick().
		
 
    ***********************************LUNES 16/3/2015******************************************************************

    EXPLICACION EJERCICIO:

    El algoritmo de planificación Round Robin consiste en fijar el tiempo (quantum) que se permitirá a un proceso utilizar la CPU de forma continuada (cuando se le termina el quantum se le desaloja y pasa a la cola de listos y mas tarde volverá a entrar a continuar con su tarea). A diferencia de este, un algoritmo FIFO provoca que el proceso al que le toca ejecutarse en CPU solo pueda salir cuando ha terminado y no pueda ser desalojado. La ventaja fundamental de RR frente a FIFO es que no retrasa a toda la cola de listos frente a un proceso muy grande, a pesar de que el tiempo de ejecución total del sistema sea el mismo. A esta situación se le llama efecto convoy y es lo que tratamos de visualizar en este ejercicio. Como Minix tiene un algoritmo de planificación RR con un quantum de 6 ticks y queremos convertirlo a FIFO, procederemos a aumentar este quantum a un numero alto, lo que provocará que el proceso tarde mucho en ser desalojado (simulando que nunca será desalojado) y que la única forma de liberar la CPU sea por propia voluntad, terminando su ejecución.
    Para realizar la tarea de cambiar el quantum tenemos que crear una nueva llamada al sistema, ya que no podemos modificar una variable de la capa del kernel desde la de usuario. En vez de crear una llamada al sistema desde cero, utilizaremos el distribuidor creado en la llamada ASOPS (creada en la practica anterior), desde el que redirigiremos a la función cambiaQ que crearemos en clock.c cuando llega la llamada CAMBIAQ. 
    IMPORTANTE: Nos prevenimos de no usar ni la constante cuantificadora PRIVATE ni FORWARD en la definición de la función ni en la declaración del prototipo de cambiaQ  en clock.c, ya que a esta función se la llamada desde este fichero system.c y estos cuantificadores impiden el acceso a funciones desde fuera del archivo en el que están escritas, ya que son una mascara de static (en C significa que esa variable/función no es accesible desde fuera del fichero).

	*************************************MARTES 24/3/2015***************************PRACTICA E*****************************************

	DUDA: ¿Cómo imprimir las tablas de segmentos de las tareas del sistema si no están en el PCB del gestor de memoria?
	EXPLICACION: Dado que las tareas de sistema no se almacenan en el PCB del gestor de memoria debemos hacer la llamada al sistema en el kernel para utilizar su PCB en el cual si que se almacenan las tareas del sistema.

	Recorremos el vector pproc_addr[] en el cual se almacenan tanto los procesos de usuario, procesos de servidores y tareas del sistema, dado que sabemos que las tareas de sistema se almacenan en primer lugar utilizaremos la constante NR_TASKS para controlar el bucle iterativo que recorrerá el PCB, accedemos al campo p_map[] de cada  proceso para imprimir la tabla de segmentos del mismo.

	Creamos la función "memLibre()" dado que la tabla de huecos esta definida como static en el fichero alloc.c, será en este fichero donde crearemos la función. 

	La tarea de la función es recorrer la lista enlazada de hole_head imprimiendo la base y el tamaño del hueco.

			while( hp != NIL_HOLE) {

				/*Impresión de los datos*/
				hp = hp->h_next;
			}


	Realizamos algunas pruebas para comprobar el funcionamiento de la tabla de huecos:

		1.-Colocando la llamada en mm_init(), antes de la llamada a mem_init(), el resultado fue la tabla vacía, dado que no se había ejecutado mem_init()(Es donde se llena la tabla de huecos).

		2.-Colocando la llamada después de la llamada a mem_init(), el resultado en este caso es una tabla con dos entradas.

		3.-Colocando la llamada en la función mem_init(), en el final del bucle el cual pide al kernel la información de que espacios de memoria están sin utilizar para así poder liberarlos, el resultado fue la evolución de la tabla(Cada iteración del bucle era una nueva entrada en la tabla de huecos).

	Para la impresión de las tablas de segmentos de los procesos de usuario creamos una nueva función llamada tabSeg(), la cual se encuentra en /usr/src/mm/utility.c, dado que ya no nos encontramos en el núcleo la estructura de datos que debemos utilizar es el PCB del gestor de memoria (mproc[NR_PROCS]), la cual esta definida en /usr/src/mm/mproc.h.
	La tarea de esta función es recorrer las entradas del PCB del gestor de memoria e imprimir la información correspondiente a la tabla de segmentos de cada una de las entradas.
	El bucle de iteración escrito es:
	for (mp = &mproc[0]; mp < &mproc[NR_PROCS]; mp++) {/* Código */}

	*********************************VIERNES 27/03/2015***********************************************************************

	Cansados de tener que acceder continuamente a /usr/src/tools para realizar la compilación del núcleo en las diferentes pruebas que hemos hecho decidimos crear un script el cual nos ahorrara las molestias

	compilak:

			#!bin/sh
			cd /usr/src/tools
			make hdboot

	Una vez escrito basta con moverlo a la carpeta /bin para poder ejecutarlo libremente, indagando un poco acerca de los scripts descubrimos que hay varias formas para ejecutarlos:

			Especificando el interprete: sh compilak
			Refiriéndose al directorio en el que estamos con el interprete predeterminado de nuestro usuario: ./compilak
			De manera global: compilak

	**********************************MIERCOLES 1/04/2015**********************************************************************

	En la última parte de la practica hemos monitorizado el funcionamiento de FORK a través de un programa imprimiendo las tablas de segmentos del padre y del hijo y la tabla de huecos, para ello creamos una nueva entrada en el distribuidor del gestor de memoria (/usr/src/mm/utility.c) la cual llamara a la nueva función tabSeg(process)(struct mproc *process), que recibe la dirección del proceso que ha realizado la llamada para así imprimir sus tablas de segmentos:

		case TABSEGTASK:
				tabSeg(&mproc[who]);
				break;
	Después creamos un pequeño programa que imprimirá la tabla de huecos y a continuación ejecutara la función fork(), en la ejecución del padre imprimimos su tabla de segmentos mediante la llamada que hemos explicado antes y esperamos a que termine la ejecución del hijo, en el caso del hijo imprimimos su tabla de segmentos y nuevamente imprimimos la tabla de huecos para comprobar las modificaciones y finalizamos.

	Tras observar brevemente los resultados obtenidos nos damos cuenta de varias cosas:

		·El proceso hijo comienza en la dirección del último hueco de la tabla.(Pues la dirección del hueco y la dirección física del segmento de texto del proceso coinciden).

		·También podemos observar que la tabla de huecos a cambiado empezando el ultimo hueco de la tabla justo al final del proceso hijo.

		·DUDA: Nos llama la atención que el proceso hijo haya sido alojado en el ultimo hueco y no en el primero, se nos ocurre la posibilidad de que el proceso no tuviera suficiente espacio en el resto de huecos, pero esto no concuerda con los resultado que hemos obtenido.

	****************************************VIERNES 17/04/2015********PRACTICA LIBRE***************************************************************

	Compactación de memoria:

	Analisis de los problemas que se nos van a presentar:
		· Cómo mover la memoria byte a byte 
		· Cómo mantener la coherencia del sistema durante la compactación
		· Algoritmo que vamos a usar para hacer los movimientos
		. Cuándo se va a hacer la compctación (a traves de un comando, cunado se llene memoria...)
		· Segmentos de texto compartidos

	**************************************MIERCOLES 22/04/2015*************************************************************************

	Para realizar la compactación de memoria es evidente que vamos a necesitar código capaz de mover memoria física de unas direcciones a otras para poder liberar y ocupar huecos. Este código debe estar escrito en lenguaje ensamblador ya que es con el que podemos mover direcciones fisicas y ademas, ya que es una operación delicada y frecuente, se debe hacer en el menor numero de tiempo posibe.
	En vez de implementar nosotros mismos esta función, utilizaremos la que usa Minix para todas sus tareas de este estilo: phys_copy. Ésta está definida en los ficheros klib386.s y klib88.s (dependeindo de sobre que arquitectura este ejecutandose Minix utilizará una u otra) del kernel.

	Comenzaremos analizando el codigo de esta función (phys_copy) en detalle, ya que será la base de todo y podremos practicar con el ensamblador de la arquitectura Intel x86 (elegimos esta porque es el que ya conocemos):

		Este codigo usa los registros de cadena del procesador (esi y edi) que almacenan direcciones de memoria. Estos registros fueron añadidos para agilizar las operaciones consecutivas sobre vectores, ya que las instrucciones que los modifican mueven el dato contenido en la dirección e incrementan/decrementan los punteros automaticamente. Estas instrucciones incrementan o decrementan esi y edi en funcion del bit de dirección (DB en el registro EFLAGS), por eso utiliza la instrucción cld, que pone a 0 este bit indicando que debe incrementar los punteros. Las instrucciones que modifican esi actuan sobre el segmento de datos (ds) y las que modifican edi sobre el segmento extra (es), pero como queremos actuar sobre el ds en el dos casos, mete en es el selector de ds (no se puede hacer mov entre dos registros de segmento por lo que usa dos instrucciones).
		A continuación saca los argumentos pasados desde los programas C de la pila (tener en cuenta que por motivos historicos los compiladores de C meten los registros en orden inverso en la pila). Usa PC_ARGS ya que previamente ha salvado los valores de tres registros de 32 bits (4 bytes) en la pila, y usa ese valor de 16 para saltarlos y poder direccionar los argumentos reales.
		

	************************************SABADO 25/04/2015************************************************************************************

	Nuestro primer paso para realizar el compactador será realizar una rutina que sea capaz de mover el segmento de datos de un proceso a otra zona de memoria libre. Para ello necesitaremos una funcion que nos de una zona de memoria libre y una llamada al sistema que pueda ejecutar la funcion phys_copy para los parametros dados. 
		· La función que nos da la zona de memoria libre es alloc_mem, escrita en alloc.c. Con esta función, para un tamaño de memoria dado (en clicks), obtenemos la dirección de inicio (en clicks) de la zona de memoria libre que podemos usar. Ésta usa el algoritmo first fit para buscar el hueco.

		· Para usar phys_copy() podemos usar una llamada al sistema predefinida en Minix: SYS_COPY. Ésta llamada se realiza a traves de la función sys_copy() implementada en /usr/src/lib/syslib/sys_copy.c. Vemos en el codigo que esta función simplemente crea un mensaje con los parámetros para phys_copy y realiza una _taskcall a SYSCALL (como todas las llamadas al sistema que hemos realizado hasta ahora). Los parametros que pasamos a esta funcion pueden ser interpretados de dos formas: 1.- Si usamos ABS donde deberiamos indicar el numero de proceso significa que vamos a indicar la dirección absoluta de la zona de memoria que vamos a mover o en la que vamos a recibir 2.- Podemos indicar el numero de proceso y la dirección virtual de memoria del segmento de ese proceso que queremos mover, para que la implementacion de sys_copy calcule las direcciones absolutas.

		La funcion recibe tres parametros los cuales indican la dirección fuente de los datos, la direccion destino de dichos datos y el numero de bytes a copiar respectivamente. Todos estos parametros son del tipo unsigned long int.

	Pasemos a explicar el codigo:

	PC_ARGS = 4 + 4 + 4 + 4 ! 4 + 4 + 4
	! es edi esi eip src dst len
	.align 16
	_phys_copy:
		cld 
		push esi
		push edi
		push es

	Lo primero que realiza esta funcion es guardar los parametros en la variable PC_ARGS, a continuacion salva los registros que se van a utilizar metiendolos en la pila.

	mov eax, FLAT_DS_SELECTOR
	mov es, ax

	mov esi, PC_ARGS(esp) 
	mov edi, PC_ARGS+4(esp)
	mov eax, PC_ARGS+4+4(esp)

	A continuacion establece los selectores de segmentos y mueve a los registrops esi, edi y eax lso parametros direccion fuente, direccion destino y cantidad de bytes a copiar respectivamente.

	cmp eax, 10 
	jb pc_small

	Realiza una comparacion de el numero de bytes a copiar con 10 esto es un valor empirico, que indica que por debajo de esta cantidad no es rentable realizar el proceso intentando copiar palabra a palabra, sino que es mas eficiente la copia byte a byte.

	mov ecx, esi
	neg ecx
	and ecx, 3 
	sub eax, ecx
	rep
	eseg movsb 
	mov ecx, eax

	En caso de que la cantidad de bytes a copiar sea superior a diez realizara la copia palabra a palabra, para esto lo primero es alinear la fuente y definir un contador para el alineamiento utilizara la instruccion "rep" para repetir la instruccion que hay inmediatamente debajo tantas veces como indica el registro ecx. Tras esto quedara en ecx el resto de los bytes que quedan por copiar.

	shr ecx, 2 
	rep
	eseg movs
	and eax, 3

	Si dividimos el valor de ecx entre 4 obtendremos el numero de palabras a copiar, utilizara de nuevo la instruccion "rep" para copiar las palabras una vez hecho esto realizara un and con 3 para despues dejar en el registro ecx el numero de bytes que faltan por copiar de la ultima palabra.

	A continuacion entrara en pc_small donde se realizara la copia de los ultimos bytes despues de esto se recuperan los valores de la pila que habiamos salvado en el inicio y termina.

	pc_small:
		xchg ecx, eax 
		rep
   eseg movsb
	pop es
	pop edi
	pop esi 
	ret

	************************************VIERNES 8/05/2015************************************************************************************
	
	Para empezar con la implementacion de nuestra practica comenzamos escribiendo una rutina capaz de mover el segmento de datos de un proceso dado a una zona de memoria, para ello como ya comentamos anteriormente necesitamos una funcion que nos de la direccion de una zona de memoria disponible, esta funcion es "alloc_mem" que esta escrita en "alloc.c" y sera en este archivo donde escribiremos nuestra rutina, para realizar la copia del segmento utilizaremos la llamada al sistema "sys_copy".

	Una vez escrito el codigo decidimos compilar el nucleo de minix, como no podia ser de otra manera el compilador notifico varios errores en el codigo que acababamos de escribir, tras pararnos a reflexionar unos minutos nos dimos cuenta que nuestra rutina no podia estar escrita en alloc.c dado que este archivo no tiene importada la estructura "mproc", la cual es fundamental para acceder a la tabla de segmentos del proceso y por lo tanto a las direcciones de estos, decidimos por lo tanto reescribir la funcion en un fichero que si que tenga importada la estructura "mproc", el archivo que elgimos en esta ocasion es "utility.c", nos decantamos por reescribir la funcion en este archivo ya que estabamos acostumrados a trabaar con el en practicas anteriores y por supuesto sabiamos que tenia importada la estructura que necesitabamos.

	Tras reubicar la rutina en "utility.c" y compilar el nucleo pudimos comprobar su funcionamiento, que efectivamente habiamos conseguido mover el segmento de datos de todos procesos a una zona de memoria diferente, esto pudimos comprobarlo gracias al comando que habiamos creado en una practica anterior el cual nos permitia ver los segmentos de los diferentes porcesos de usuario en memoria en un momento dado, pero habia algo que no funcionaba correctamente ya que una vez realizado la reubicacion de los segmantos de datos el sistema comenzaba a degradarse hasta el punto de dejar de funcionar por completo, tras unas cuantas pruebas nos dimos cuenta que estabamos abordando el problema de una forma demasiado brusca y decidimos modificar la rutina para que en vez de mover el segmento de datos de todos los procesos de usuario, moviese soloamente el segmento de datos del proceso que nosotros le indicasemos a traves del PID del proceso "victima", tras hablar con el profesor decidimos hacer las pruebas con un pequeño programa de calculo de primos que imprimia puntos en pantalla a medida que calcula los numeros. Como era de esperar tras realizar la operacion sobre este proceso el proceso terminaba su ejecucion.

	Decidimos estudiar mas en profundidad la gestion de memoria de minix y como estaban organizados los segmentos de los procesos en memoria, una vez habiamos estudiado todo lo necesario nos dimos cuenta de un fallo importante: 

		En minix la tabla de segmentos tiene 3 entradas una para cada segmento del proceso(Datos, Texto y Pila), pero en memoria esto no es exactamente igual ya que para los tres segmentos cada proceso tiene dos huecos de memoria asignados, un hueco para el segmento de texto y otro hueco que se comparte entre el segmento de datos y el de pila, asi como un espacio extra(gap) que permite a estos dos ultimos crecer durante la ejecucion. Por lo tanto decidimos volver a modificar el codigo pero esta vez desplazando el segmento de datos y pila como una unica zona de memoria. 
		Dado que el proceso que ibamos a mover en las pruebas tenia texto y datos juntos es decir no habia dos zonas de memoria separadas para el texto y los datos decidimos calcular las direcciones de manera que pudiesemos mover todos los segmentos como un unico boque.

	Tuvimos un problema a la hora de realizar los calculos de las direcciones para que fuesen correctos, el cual fue fue no calcular correctamente el espacio total del proceso:

		·Para calcular el espacio total del proceso valdria con restar la direccion fisica del segmento de datos con la direccion fisica del segmento de pila, esa fue la operacion que realizamos en un principio, tras un poco de reflexion y el estudio de la funcion "do_fork", nos dimos cuenta que se nos olvidaba algo importante.

		·Para calcular correctamente el espacio total debeiamos restar la direccion fisica del segmento de datos y del segmento de pila, pero tambien debiamos tener en cuenta el tamaño actual de la pila en ese momento ya que la direccion fisica del segmento de datos comienza en el punto donde comienzan los datos, pero la direccion de la pila apunta a la ultima direccion de la pila(que crece hacia arriba), por lo tanto debiamos sumar el tamaño de la pila en el momento de realizar la reubicacion.


	Ya que lo teniamos todo claro y un nuevo codigo decidimos repetir las pruebas, en esta ocasion los resultados fueron satisfactorios en un principio ya que despues de lanzar el proceso "victima"(que calculaba numeros primos e imprimia puntos en pantalla), logramos moverlo a una zona diferente de memoria y que continuase con su ejecucucion, tras realizar unas cuantas pruebas nos dimos cuenta que tras este triunfo habia un "pero", el problema que surgio era que tras mover el proceso y este seguir ejecutando al crear un nuevo proceso de usuario el primero terminaba su ejecucion, nos sorprendio que este fallo provocara una terminacion tan "amigable" del proceso ya que en la mayoria de las ocasiones no notificaba ningun error en la ejecucion.

	Se nos plantearon varias dudas de por que se producia este fallo:

		·¿Podria deberse a un segmento de texto compartido?
			-No, ya que el proceso que hemos utilizado en las pruebas no tiene texto compartido, aun asi decidimos probar reubicando un proceso del editor de textos de minix "vi", el cual si tiene el segemento de texto compartido, como era de esperar al realizar la reubicacion del proceso este terminaba su ejecucion.

		·¿Podria estar el problema en que el texto y los datos esten juntos?
			-No, decidimos probar a mover los segmentos por separado, obteniendo un resultado muy similar al de las anteriores pruebas.

		·¿Quizas no entendamos como funciona la gestion de memoria en minix?
			-Tras mucho tiempo pensando y dandole vueltas llegamos a la conclusion de que habia algun detalle que se nos escapaba o que no entendiamos bien, para intentar solucionarlo decidimos volver a estudiar la gestion de memoria a traves del libo: "Sistemas operativos: Diseño e implementacion", ademas de estudiar en profundidad las funciones FORK y EXEC.

	Una vez con todos los conceptos claros no encontrabamos explicacion a nuestro problema, por lo tanto decidimos seguir estudiando para intentar dar con la solucion en un futuro cercano.

	Cabe destacar que gran parte del codigo que hemos escrito ha sido corregido a partir del estudio de las funciones FORK y EXEC de minix.