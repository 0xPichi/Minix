Autores: Sergio Delgado Álvarez y Alberto Amigo Alonso
Grupo: 27

****** LUNES 09/02/2015 *************** 16:00 ********************************************************************************************* 
**************************************************** VI **********************************************************************************

El editor de textos Vi tiene dos modos el modo de edición y el modo comandos los comandos básicos del Vi son:

	- ESC -> Salir al modo comando.
	- i -> Insertar en la posición en la que se encuentre el cursor.
	- a -> Insertar en la posición siguiente a la que se encuentra el cursor.
	- x -> Borra la posición en la que se encuentre el cursor.
	- nyy -> Copiar la línea en la que se encuentra situado el cursor.
	- p -> Pegar en la posición en la que se encuentre el cursor.
	- ndd -> Borra n líneas empezando en la que se encuentra el cursor
	- u -> Deshacer el ultimo cambio efectuado.
	- :q -> Salir del editor.
	- :q! -> Forzar salida del editor.
	- :w -> Guardar los cambios realizados.
	- :wq -> Guardar y salir del editor.
	- /loquebuscas -> Busca la cadena loquebuscas en el fichero
	- :lineaquebuscas -> Busca la línea lineaquebuscas en el fichero.
	- G -> Baja hasta el final del fichero.
	- Ctrl+g -> Muestra el nombre del fichero entre otras cosas.
	- o -> Coloca el cursor en la line inferior a la actual.
	- O -> Coloca el cursor en la línea posterior a la actual.
	- A -> Coloca el cursor al final de la línea.
	- % -> Con el cursor colocado en una llave o paréntesis desplaza el cursor hasta la llave o paréntesis que lo cierran.

Para movernos por el texto se utilizan las flechas de dirección del teclado en el modo comando, en caso de no funcionar los cursores puede ser debido a que el BloqNum esta activado, es importante asegurarse de que esté desactivado antes de comenzar a trabajar.

***************PRACTICA A****************************************************************************************************

El archivo /etc/passwd es un archivo en el cual se guardan varias configuraciones del sistema en los SO tipo Unix.
Recomendable aprender a programar Shell Scripting.

· COMPILACIÓN DEL NÚCLEO 

Añadida la referencia a el comando VI para buscar en un fichero por facilidad de trabajo.
PROBLEMA: A pesar de que añadimos un printf, no se muestra en la pantalla de inicio.
EXPLICACIÓN: Error evidente, aún no se había compilado el nuevo kernel, por lo que el mensaje solo era una línea de texto en un fichero

Compilamos el núcleo y comprobamos que efectivamente se hace un "cp image /dev/hd1a:/minix/2.0.0r12", es decir, se hace una copia del nuevo núcleo con su revisión en /minix (aparece la versión 2.0.0r12 cuando "ls /minix"). Ahora si que aparece el mensaje añadido de bienvenida cuando reiniciamos el sistema. También probamos a borrar /minix/2.0.0r12 para comprobar que al reiniciar no aparece el mensaje modificado, ya que se ejecuta la anterior copia del núcleo

· PROGRAMA EN C 

Para crear un programa en C utilizaremos "$ vi creaH.c". En primer lugar debemos importar los ficheros de cabecera necesarios para las funciones que vamos a utilizar, a continuación declaramos las variables externas.
#import <stdlib.h>
#import <errno.h>

main (int argc, char *argv[]){

Declararemos una variable de tipo entero que se llamara "numH", lo primero que haremos es comprobar que me han pasado el numero de  los argumentos correctamente:

int numH, i, ret ;
"if(argc != 2){
	printf("creaH <numHijos>\n");
	exit(-1);
	}"

A continuación comprobaremos los argumentos que hay en "argv[]", como lo que entra por teclado no es un numero sino una cadena de caracteres alfanuméricos, lo que habría almacenado en la posición 0 de "argv[0]"seria una cadena de caracteres, para pasarlo a un entero utilizaremos la función "atoi" para el cual habría que incluir el fichero de cabecera "stdlib.h" (esto lo vemos con "$ man atoi")

numH = atoi(argv[1]);
for(i = 0; i < numH-1; i++){
	if((ret = fork()) == 0){    /* Se almacena en ret el valor del fork y luego compara con el 0. */
	hijo();
	exit(0);
	}
	else if (ret < 0){
		/*error en fork*/
		perror("fork");
		printf("Creados %d, procesos\n", i);
		exit(-1);
	}
}

Después habrá que declarar la función "hijo()". No hará nada, solo emula la estructura del código

hijo(){	
}

Para compilar saldremos de Vi con ":wq", y utilizaremos el comando: "cc -o creaH creaH.c", el ejecutable ha de llamarse siempre igual que el código pero sin la extensión.

La finalidad de este programa es ver cuantos procesos se pueden crear en un sistema MINIX.
Para ejecutar este programa una vez compilado:
$ ./creaH "numHilos" 

PROBLEMA: No conseguimos compilar el programa y ejecutarlo (solucionado el día 23/2/2015, mirar en esta fecha)

*************************JUEVES 19/02/2015******************PRACTICA B****************************************************************


Para encontrar la función que trata la llamada al sistema de "fork()", seguimos la pista de las diferentes funciones tal y como aparece en el enunciado de la practica hasta llegar a "call_vec[]", el cual es un vector de funciones que guarda los nombres de las diferentes funciones para tratar las llamadas al sistema.

Seguimiento completo de una llamada fork();
	
	1º- (MU) Cuando invocamos desde un programa la llamada al sistema fork() (posix/_fork.c), se ejecuta una llamada a la función _syscall(MM, FORK, &m).

	EXPLICACION:

	Es interesante señalar que la función fork() devuelve un valor del tipo pid_t, que es el PID del hijo que se da al padre al ejecutar la llamada. 
	Observando el código de otras llamadas al sistema como wait(), podemos ver que en todas ellas se sigue el patrón de llamada a _syscall(MM, *, &m), por lo que * es el argumento mas importante de este paso, ya que es el que identifica el tipo de llamada al sistema que estamos realizando (mediante las constantes alfanuméricas de callnr).
	El parámetro m se declara de tipo message en la función fork(); 

	2º- (MU) Esta función invoca a su vez a _sendrec().

	EXPLICACION:

	El parámetro m, ya declarado en fork(), se empieza a definir en la función _syscall(), llenando el campo m_type(El tipo de datos message corresponde a una estructura que se basa en dos variables: m_source, que indica quien manda el mensaje y m_type, que indica que tipo de mensaje es.).En este caso el tipo de mensaje definido es FORK.
	A la función _sendrec() se le pasan como parámetros el servidor que ha de tratar la llamada al sistema (MM) y el mensaje con el tipo ya definido.

	3º- (MU) Desde _sendrec() lanza la interrupción software int SYSVEC la cual hace que a partir de este punto el procesador cambie a modo privilegiado(MP).

	EXPLICACION:

	El compilador de C guarda en la pila los argumentos de llamada a una función, por eso la función en ensamblador sendrec guarda esos valores en los registros de propósito general sacándolos de la pila y después realiza la interrupción (que utilizará los valores de estos registros para definir como se ha de tratar la interrupción).
	La interrupción que se lanza es la 21h. 

**********************************************SABADO 21/02/2015****************************************************************************************

	4º- (MP) El sistema pasara al tratamiento de la interrupción para ello la función prot_init() inicializa la tabla de vectores de interrupción. La recepción de la interrupción esta asociada con la función s_call().

	EXPLICACION:

	idt es una variable global declarada en protect.c como un vector de struct gatedesc_s de tamaño IDT_SIZE. Siguiendo la pista a IDT_SIZE lo encontramos definido en protect.h con el valor IRQ8_VECTOR + 8, estando esta definida en const.h con el valor 48 (0x30), por lo que el vector tiene tamaño 56. 	
	En la función int_gate() es donde se referencia a idt[33] (el argumento formal vec_nr tomar el valor 33) asignándole la correspondencia con s_call.

	Comprobando la línea 206 del archivo /usr/src/kernel/protect.c con el nuevo comando añadido a la lista de Vi, observamos que el vector SYS386_VECTOR esta asociado con la función s_call().

	5º- (MP) La función s_call() invoca a la función sys_call(), cuyos argumentos habían sido insertados previamente en la pila.

	6º- (MP) La función sys_call() es la encargada de enviar el mensaje al servidor apropiado en el ejemplo del fork() el servidor es MM y el mensaje es FORK (Este FORK es una constante que representará la llamada a la función que tratará a fork() en call_vec[]).

	EXPLICACION:

	La función sys_call() recibe tres parámetros, el mas relevante es el primero de ellos "function", que determina si se va a enviar un mensaje, recibir un mensaje o ambos (send, recive o sendrec). En nuestro caso llega sendrec.
	La función que se invoca para enviar el mensaje al servidor es mini_send(), la cual se encarga de comprobar que el receptor del mensaje esta esperando ha recibir dicho mensaje, tras enviar el mensaje, bloquea el proceso que envía el mensaje. La función que se invoca para recibir el mensaje es mini_rec(), que comprobará que tiene un mensaje para recibir y desbloquea el emisor de este mensaje.


	7º- (MP) Una vez que sys_call() ha enviado el mensaje a MM, se ejecuta _restart() en mpx386.s. Esta función permitirá continuar con la ejecución de otro proceso, normalmente en nuestro caso será MM ya que ha de tratar el mensaje que previamente le había mandado sys_call(), en este punto el procesador vuelve de nuevo a modo usuario (MU) 

	8º- (MU) El main del MM que estaba a la espera de recibir un mensaje ejecutando en un bucle infinito la función get_work(), una vez ha recibido el mensaje se invoca a la función que ha de tratarlo a través de un vector de funciones llamado call_vec[], en nuestro caso call_vec[2] = do_fork, esta será la función encargada del tratamiento de la llamada al sistema.

	EXPLICACION Y RESPUESTA EJERCICIO 2:

	En el main de usr/src/mm/main.c se declaran e inicializan las variables que usará el gestor de memoria llamando a la función mm_init() (podemos ver que ésta inicialización se realiza con el arranque del sistema porque están escritos los printf con información de la memoria que se muestran en el login). Después de esta inicialización el gestor entra en un bucle infinito: lo primero que hará será llamar a la función get_work, que intentará leer un mensaje mediante la función receive y en caso de conseguirlo lo "decodificará" definiendo los nuevos valores para who y mm_call. Esta última variable será especialmente importante ya que almacena el tipo de mensaje enviado (call number) que en nuestro caso, recordemos, será FORK = 2. Este valor es un "call number" valido por lo que se ejecutará (*call_vec[mm_call])(). En este punto debemos buscar dónde se encuentra inicializado el vector call_vec[], por lo que hacemos "grep call_vec *" en el directorio mm en el que nos encontramos: el resultado es table.c. En este fichero vemos el vector y buscamos la posición 2 correspondiente al mensaje de FORK, que nos conduce a la función do_fork. De nuevo hacemos "grep do_fork *" para buscar donde se encuentra esta función y obtenemos como resultado el fichero forkexit.c. Es aquí donde añadiremos el printf con el saludo.

	Como complemento a la practica A nos fijamos en la línea de la función do_fork que comprueba if (procs_in_use == NR_PROCS) return EAGAIN, lo que justifica empíricamente por qué al cambiar el valor de la constante NR_PROCS pueden coexistir mas procesos, es decir, pueden hacerse mas fork().

	*****************************************MIERCOLES 25/02/2015************************************************************************************

	Tras la realización de la modificación en la practica "B", comprobamos su funcionamiento compilando nuevamente el núcleo desde /usr/src/tools ejecutando el comando "make hdboot" y reiniciando el sistema vemos que en el arranque del sistema aparece el mensaje de saludo en repetidas ocasiones y también al ejecutar el programa de la practica A (esto es porque se crean procesos para muchas tareas del SO ya que Minix está basado en el modelo de creación de procesos fork/wait/exit). 
	PROBLEMA: probamos a ejecutar un par de comandos como "ls", "cd". Observamos que tras ejecutar "ls" aparece nuestro saludo y se nos ocurre ir a buscar el "fork" que producía ese saludo al fichero /usr/src/commands/ls.c. Después de buscarlo en el código no lo encontramos.
	EXPLICACION: Nos equivocamos en el concepto, no es ls el que lanza un proceso nuevo mediante fork, sino que es el Shell del sistema operativo el que usa fork para crear un nuevo proceso y después le asigna mediante una instrucción exec el código del programa ls.c que es el que será ejecutado.
	PROBLEMA: El comando "cd" no crea ningún proceso (no muestra nuestro mensaje de saludo cuando lo lanzamos). Como el "ls" si que lo creaba nos parecía raro pensar que otro comando como "cd" no generase ninguno.
	EXPLICACION: La explicación de este problema es que no todos los comandos generan procesos, sino que invocan una rutina interna del "bash.c"(Programación en Shell).

	EXPLICACION (Problema de compilación del primer programa): El problema residía en que en las versiones mas primitivas de C, como la que compila el compilador cc, las declaraciones de las variables deben de realizarse en las primeras líneas de la función. 
	Una vez arreglado este error podemos ver que el programa falla al crear 27 hijos, sin embargo hemos visto en el fichero /usr/include/minix/config.h que el valor NR_PROCS está definido con el valor 40, que es el número de procesos concurrentes que pueden coexistir en la maquina, por lo que podemos suponer que ya hay 13 procesos en ejecución (getty, etc), y por eso solo quedan 27 para poder ejecutar. Probamos a modificar este fichero de cabecera y cambiar la constante a 100 y al ejecutar el programa creaH podemos ver que se crean hasta 73 hijos, es decir, mas procesos concurrentes.
	ACLARACIÓN: Los procesos de las tareas del sistema no entran dentro de estos 40 procesos. Son solo procesos de usuario. (Las tareas las define NR_TASKS, no NR_PROCS)

	*************************************MIERCOLES 4/03/2015*************PRACTICA C******************************

	Comenzamos a implementar nuestra propia llamada al sistema ASOPS de ejemplo que simplemente jugará a modificar e imprimir en pantalla algunos parámetros del mensaje que se pasa como información básica de la llamada. Esta llamada al sistema pasará desde la capa de usuario (nivel 4) al servidor de memoria (nivel 3) y de este pasará a la tarea del sistema (nivel 2 - kernel)

	En primer lugar, añadimos la constante alfanumérica que identificará a nuestra llamada en el sistema operativo (por motivos de limpieza del código) en el fichero de cabecera "callnr.h".
	A continuación haremos las modificaciones propias en el gestor de memoria: 
		· En usr/src/mm/main.c está el bucle que espera la recepción de un mensaje nuevo a este servidor (visto en la practica B), que cuando lo recibe busca en el vector call_vec[] por índice el número de llamada al sistema que se está pidiendo (constante alfanumérica que añadimos anteriormente), por lo que añadiremos en este array (table.c) la entrada correspondiente a nuestro ASOPS con la correspondiente función que ha de invocar en la posición que le toca (esta será el índice de la constante alfanumérica). "call_vec" tiene tamaño NCALLS por lo que si se nos hubiese olvidado incrementar este valor en callnr.h habríamos cometido un error. 
		· También debemos volver operativa esta función, esto implica escribir el prototipo de la función en proto.h y desarrollar el código de do_asops en un fichero como por ejemplo utility.c. Este código se dividirá en tres secciones: mostrar los parámetros del mensaje que le llegan al servidor de memoria, invocar a la tarea del sistema que realizará otra función y almacenar los cambios que la tarea ha realizado.
		Dos cuestiones importantes de señalar acerca de este código son las siguientes: 1º- Los structs de tipo message no tienen campos que se llama m1_i1, m1_i2, etc, sino que  son constantes que están definidas en type.h para acceder de una forma simple a los campos de la union de estas estructuras (m_u.m_m1.m1i1), 2º- mm_in y mm_out son estructuras globales que utilizamos para la recepción y envió del mensaje desde el mm.

		ACLARACIÓN: Para añadir los prototipos de las funciones (sus declaraciones) utilizamos la macro _PROTOTYPE a la que pasamos como "parámetros" el nombre de la función y los argumentos. Esta macro transforma esta declaración de dos formas diferentes en función del valor que tenga otra macro. Investigando descubrimos que existen dos tipos de formas de escribir código en C: la originalmente diseñada por sus creadores Kernighan y Ritchie (K&R C) y la estandarizada por la IEEE (ANSI C). Como los diseñadores de Minix no podían saber cuál de estas dos formas iba a ser usada decidieron crear la macro _PROTOTYPE para poder cambiar entre las dos versiones de una forma simple.

	********************************JUEVES 5/03/2015**********************************************

	Seguiremos con las modificaciones de la tarea del sistema:
		· El fichero usr/src/kernel/system.c proporciona una interfaz para atender las llamadas a la tarea del sistema. En este fichero escribimos el prototipo de la función do_asops que ejecutará el kernel, a la que se pasará como parámetro el mensaje con la información (se lo pasará _taskcall())
		DUDA: ¿Por qué en el paso del mensaje a MM no hay que pasar el mensaje como argumento y a la SYSTASK si? 
		RESPUESTA: Elección de diseño de los desarrolladores de Minix.
		EXPLICACION: 
		· En la rutina sys_task() se demultiplexa a la llamada a la función dependiendo de la llamada al sistema que se produzca (en este caso ASOPS), por lo que tenemos que añadir un case en el switch para invocar a la función do_asops()
		· Escribimos el código de do_asops() en el que haremos algo parecido al del servidor de memoria, es decir, cambiar los parámetros del mensaje e imprimir los anteriores para comprobar que se están efectuando de buena forma los pasos.

    ********************************MIERCOLES 11/03/2015***************PRACTICA D*******************************

    Para terminar la Practica C crearemos una llamada al sistema con una utilidad especial: mostrar información sobre los procesos actualmente en ejecución. Para no tener que hacer todas las modificaciones en todos los ficheros de nuevo, utilizaremos un distribuidor en la función do_asops de el kernel (system.c) que se bifurcará en función del valor m1_i1 (primer campo del primer campo de la unión de message) del mensaje. Estos valores representarán, mediante constantes alfanuméricas que definiremos en usr/include/minix/type.c, a las llamadas al sistema que crearemos a continuación.
    Nuestra llamada para mostrar información de los procesos será MIPS, ejecutada en la función do_mips. Esta función recorre todos los procesos existen en el instante de ejecución (utilizando pproc_addr, que guarda por orden de llegada las direcciones de los procesos, y la mascara P_SLOT_FREE negando el resultado) e imprime por pantalla información sobre ellos como su PID (se imprime como un entero, ya que en usr/src/kernel/types.c está definido como un tipo "renombrado" de int), nombre, numero de proceso, tiempo de usuario y tiempo de CPU...

    Comenzamos la practica D:

    RETO 1: ¿Milisegundos del ciclo de reloj? La definición del quantum de minix se encuentra en /usr/src/kernel/clock.c definida como SCHED_RATE (MILLISEC*HZ/1000), dado que MILLISEC definido también en este archivo tiene un valor de 100 y HZ un valor de 60 definido en /usr/include/minix/cons.h, por lo tanto el valor definido para SCHED_RATE es de 6 ticks siendo cada tick 1000/60 milisegundos el valor del quanto de minix es 100 milisegundos.
    RETO 2: ¿Por qué el ultimo proceso que se crea es el primero en entrar en CPU? Explicado con la función ready()
    
    A continuación exponemos los factores que nos resultan significativos de las funciones pick_proc(), ready(), unready() y sched() que están en /usr/src/kernel/proc.c

    	· pick_proc() -> Es la función encargada de coger un proceso de la cola de listos y asignarle CPU.
    	 Lo primero que nos llama la atención es que las colas tienen una prioridad asignada TASK_Q > SERVER_Q > USER_Q por lo cual la función trata de asignar CPU en primer lugar a los procesos listos de la tarea del sistema, en caso de no haber ninguno ejecuta el resto en orden de prioridades.
    	 Es en esta función donde se define las variables globales proc_ptr y bill_ptr que están declaradas en proc.h y que representan el proceso que esta actualmente en ejecución y el proceso que inicia una serie de llamadas al sistema respectivamente.
    	 Podemos ver que la variable bill_ptr solo se utiliza en los procesos de usuario ya que es el único que puede hacer llamadas al sistema y que necesita saber quien es el emisor de la llamada al que "cobrar" la CPU.
    	 No devuelve el proceso, sino que almacena su referencia en proc_ptr.

   	*******************************SABADO 14/3/2015***********************************************************************

    	· ready() -> Mete un proceso en la cola de listos. PROBLEMA: ¿Que quiere decir la macro istaskp? EXPLIACION: Realiza la comprobación de si el proceso es una tarea del sistema. Vemos que la cola de procesos listos se implementa con una política LIFO (esto se realiza en O(1) y no provoca un problema ya que el PCB se implementa mediante listas enlazadas). Se puede cambiar a una política FIFO descomentando las líneas siguientes y comentando las anteriores. Es sencillo leyendo el código darse cuenta de esto, ya que en la implementación LIFO se mete toda la cola detrás del proceso que vamos a añadir y después se pone este el primero y en la FIFO se le coloca el último.
    	· unready() -> Saca un proceso de la cola de listos. Es algo menos eficiente que ready(), ya que el proceso que eliminamos no tiene por qué ser el primero y al estar implementado mediante listas enlazadas necesitamos recorrer toda la lista hasta encontrar el proceso (eliminarlo es sencillo, ya que simplemente cambiamos la referencia del nextready del proceso anterior al que queremos eliminar por la del proceso que sigue al eliminado)
    	· sched() -> Se invoca a este método cuando el proceso en ejecución ha superado el quantum (demasiado tiempo en CPU). Mete este proceso al final de la cola y pone el que estaba el segundo en la cabeza. A continuación llama a la función pick_proc() que, si no hay procesos de tareas o servidores, seleccionará a este proceso para asignarle CPU. Importante señalar que ésta función solo trabaja con procesos de usuario DUDA:¿Es porque las tareas del sistema y procesos de servidores no pueden ser desalojados? EXPLICACION: Efectivamente las tareas del sistema y los procesos de servidores no son desalojados nunca de CPU debido a la política del sistema operativo.


    Tras leer y analizar la tarea del reloj llegamos a comprender su funcionamiento:

   	En la inicialización del sistema se invoca a todas las tareas incluida la tarea del reloj, lo primero que podemos observar que la tarea llama a la función init_clock() la cual efectúa la inicialización del temporizador externo, determina el numero de ciclos entre interrupciones, inicializa la rutina de servicio de interrupción del reloj y habilita las interrupciones. El valor del numero de ciclos entre interrupción esta definido en const.h como TIMER_FREQ/HZ por lo tanto el reloj interrumpe 60 veces por segundo. Después de esto la tarea del reloj se queda esperando recibir algún mensaje.
	Por lo tanto el reloj interrumpe 60 veces por segundo lanzando una interrupción, que es tratada por la CPU llamando a la rutina de servicio de interrupciones del reloj(clock_handler()), lo primero que hace esta rutina de servicio es contar los ticks que lleva que lleva el proceso en ejecución, esta rutina debería de actualizar la variable realtime, pero ya que esta protegida actualiza pending_ticks y now, la variable sched_ticks cuenta los ticks que le quedan al proceso para finalizar su quantum, se comprueba que llegue a 0 si se da esta situación se invoca a interrupt(CLOCK), pero solo en caso de que el proceso sea un proceso de usuario. Esto provoca el envió de un mensaje a la tarea del reloj, de tipo HARD_INT, tras la llegada de este mensaje a la tarea del reloj utiliza el distribuidor para ejecutar la función asociada a este tipo de mensaje que en el caso de HARD_INT es do_clocktick().
		
 
    ***********************************LUNES 16/3/2015******************************************************************

    EXPLICACION EJERCICIO:

    El algoritmo de planificación Round Robin consiste en fijar el tiempo (quantum) que se permitirá a un proceso utilizar la CPU de forma continuada (cuando se le termina el quantum se le desaloja y pasa a la cola de listos y mas tarde volverá a entrar a continuar con su tarea). A diferencia de este, un algoritmo FIFO provoca que el proceso al que le toca ejecutarse en CPU solo pueda salir cuando ha terminado y no pueda ser desalojado. La ventaja fundamental de RR frente a FIFO es que no retrasa a toda la cola de listos frente a un proceso muy grande, a pesar de que el tiempo de ejecución total del sistema sea el mismo. A esta situación se le llama efecto convoy y es lo que tratamos de visualizar en este ejercicio. Como Minix tiene un algoritmo de planificación RR con un quantum de 6 ticks y queremos convertirlo a FIFO, procederemos a aumentar este quantum a un numero alto, lo que provocará que el proceso tarde mucho en ser desalojado (simulando que nunca será desalojado) y que la única forma de liberar la CPU sea por propia voluntad, terminando su ejecución.
    Para realizar la tarea de cambiar el quantum tenemos que crear una nueva llamada al sistema, ya que no podemos modificar una variable de la capa del kernel desde la de usuario. En vez de crear una llamada al sistema desde cero, utilizaremos el distribuidor creado en la llamada ASOPS (creada en la practica anterior), desde el que redirigiremos a la función cambiaQ que crearemos en clock.c cuando llega la llamada CAMBIAQ. 
    IMPORTANTE: Nos prevenimos de no usar ni la constante cuantificadora PRIVATE ni FORWARD en la definición de la función ni en la declaración del prototipo de cambiaQ  en clock.c, ya que a esta función se la llamada desde este fichero system.c y estos cuantificadores impiden el acceso a funciones desde fuera del archivo en el que están escritas, ya que son una mascara de static (en C significa que esa variable/función no es accesible desde fuera del fichero).

	*************************************MARTES 24/3/2015***************************PRACTICA E*****************************************

	DUDA: ¿Cómo imprimir las tablas de segmentos de las tareas del sistema si no están en el PCB del gestor de memoria?
	EXPLICACION: Dado que las tareas de sistema no se almacenan en el PCB del gestor de memoria debemos hacer la llamada al sistema en el kernel para utilizar su PCB en el cual si que se almacenan las tareas del sistema.

	Recorremos el vector pproc_addr[] en el cual se almacenan tanto los procesos de usuario, procesos de servidores y tareas del sistema, dado que sabemos que las tareas de sistema se almacenan en primer lugar utilizaremos la constante NR_TASKS para controlar el bucle iterativo que recorrerá el PCB, accedemos al campo p_map[] de cada  proceso para imprimir la tabla de segmentos del mismo.

	Creamos la función "memLibre()" dado que la tabla de huecos esta definida como static en el fichero alloc.c, será en este fichero donde crearemos la función. 

	La tarea de la función es recorrer la lista enlazada de hole_head imprimiendo la base y el tamaño del hueco.

			while( hp != NIL_HOLE) {

				/*Impresión de los datos*/
				hp = hp->h_next;
			}


	Realizamos algunas pruebas para comprobar el funcionamiento de la tabla de huecos:

		1.-Colocando la llamada en mm_init(), antes de la llamada a mem_init(), el resultado fue la tabla vacía, dado que no se había ejecutado mem_init()(Es donde se llena la tabla de huecos).

		2.-Colocando la llamada después de la llamada a mem_init(), el resultado en este caso es una tabla con dos entradas.

		3.-Colocando la llamada en la función mem_init(), en el final del bucle el cual pide al kernel la información de que espacios de memoria están sin utilizar para así poder liberarlos, el resultado fue la evolución de la tabla(Cada iteración del bucle era una nueva entrada en la tabla de huecos).

	Para la impresión de las tablas de segmentos de los procesos de usuario creamos una nueva función llamada tabSeg(), la cual se encuentra en /usr/src/mm/utility.c, dado que ya no nos encontramos en el núcleo la estructura de datos que debemos utilizar es el PCB del gestor de memoria (mproc[NR_PROCS]), la cual esta definida en /usr/src/mm/mproc.h.
	La tarea de esta función es recorrer las entradas del PCB del gestor de memoria e imprimir la información correspondiente a la tabla de segmentos de cada una de las entradas.
	El bucle de iteración escrito es:
	for (mp = &mproc[0]; mp < &mproc[NR_PROCS]; mp++) {/* Código */}

	*********************************VIERNES 27/03/2015***********************************************************************

	Cansados de tener que acceder continuamente a /usr/src/tools para realizar la compilación del núcleo en las diferentes pruebas que hemos hecho decidimos crear un script el cual nos ahorrara las molestias

	compilak:

			#!bin/sh
			cd /usr/src/tools
			make hdboot

	Una vez escrito basta con moverlo a la carpeta /bin para poder ejecutarlo libremente, indagando un poco acerca de los scripts descubrimos que hay varias formas para ejecutarlos:

			Especificando el interprete: sh compilak
			Refiriéndose al directorio en el que estamos con el interprete predeterminado de nuestro usuario: ./compilak
			De manera global: compilak

	**********************************MIERCOLES 1/04/2015**********************************************************************

	En la última parte de la practica hemos monitorizado el funcionamiento de FORK a través de un programa imprimiendo las tablas de segmentos del padre y del hijo y la tabla de huecos, para ello creamos una nueva entrada en el distribuidor del gestor de memoria (/usr/src/mm/utility.c) la cual llamara a la nueva función tabSeg(process)(struct mproc *process), que recibe la dirección del proceso que ha realizado la llamada para así imprimir sus tablas de segmentos:

		case TABSEGTASK:
				tabSeg(&mproc[who]);
				break;
	Después creamos un pequeño programa que imprimirá la tabla de huecos y a continuación ejecutara la función fork(), en la ejecución del padre imprimimos su tabla de segmentos mediante la llamada que hemos explicado antes y esperamos a que termine la ejecución del hijo, en el caso del hijo imprimimos su tabla de segmentos y nuevamente imprimimos la tabla de huecos para comprobar las modificaciones y finalizamos.

	Tras observar brevemente los resultados obtenidos nos damos cuenta de varias cosas:

		·El proceso hijo comienza en la dirección del último hueco de la tabla.(Pues la dirección del hueco y la dirección física del segmento de texto del proceso coinciden).

		·También podemos observar que la tabla de huecos a cambiado empezando el ultimo hueco de la tabla justo al final del proceso hijo.

		·DUDA: Nos llama la atención que el proceso hijo haya sido alojado en el ultimo hueco y no en el primero, se nos ocurre la posibilidad de que el proceso no tuviera suficiente espacio en el resto de huecos, pero esto no concuerda con los resultado que hemos obtenido.
